---
layout: post
author: cangqing
---

#### 问题描述：
调度系统中常见的任务类型是hive sql，spark sql等，这些任务根据sql 的输入和输出表自发的建立起一套先后次序，自然任务之间也就有了依赖关系。本文描述在系统设计中如何维护这些依赖关系：
- 如何存储依赖关系？
- 如何维护依赖关系？
- 如何进行环检测？

#### 依赖关系存储模型

##### 任务存储模型

| 任务Id | 任务类型 | 脚本文件
| ------ | ------ | ------
| 100 | hive | hive-demo.sql |
| 101 | spark | spark-demo.sql |

##### 脚本的输入输出存储模型

| 任务Id | 输入输出类型 | 表名称
| ------ | ------ | ------|
| 100 | 1 | table0 |
| 100 | 2 | table1 |
| 101 | 1 | table1 |
| 101 | 2 | table2 |
| 102 | 1 | table1 |
| 102 | 2 | table3 |

这样建立起了任务101和102依赖任务100.对应的任务依赖关系则可以表示为下表。
##### 任务依赖关系存储模型

| 任务Id | 父任务Id |
| ------ | ------ | 
| 100 | 0 |
| 101 | 100 |
| 102 | 100 |

父任务100（顶级节点）用一个虚拟节点任务0表示。箭头方向代表数据流向。

<div class="mermaid">
graph TD
A[100]-->B(101);
A[100]-->C(102);
</div>

那么问题来了，如何对这个存储模型增、删、改、查？

#### 依赖关系维护
##### 新增一个节点
增加一个任务103，依赖101，输入表输入输出表更新如下：

| 任务Id | 输入输出类型 | 表名称|
| ------ | ------ | ------|
| 100 | 1 | table0 |
| 100 | 2 | table1 |
| 101 | 1 | table1 |
| 101 | 2 | table2 |
| 102 | 1 | table1 |
| 102 | 2 | table3 |
| 103 | 1 | table1 |

对应的依赖表更新如下：

| 任务Id | 父任务Id |
| ------ | ------ | 
| 100 | 0 |
| 101 | 100 |
| 102 | 100 |
| 103 | 101 |

则新的依赖树为：

<div class="mermaid">
graph TD
A[100]-->B(101)
A[100]-->C(102)
B[101]-->D(103)
</div>

##### 删除原有节点
原则上只能删除叶子节点，有下游依赖的节点不允许删除。

##### 修改原有节点
现在增加任务101输入表table3，此时表存储和依赖关系更新为：

| 任务Id | 输入输出类型 | 表名称
| ------ | ------ | ------
| 100 | 1 | table0 |
| 100 | 2 | table1 |
| 101 | 1 | table1 |
| 101 | 1 | table3 |
| 101 | 2 | table2 |
| 102 | 1 | table1 |
| 102 | 2 | table3 |
| 103 | 1 | table1 |

对应的依赖表更新如下：

| 任务Id | 父任务Id |
| ------ | ------ | 
| 100 | 0 |
| 101 | 100 |
| 102 | 100 |
| 103 | 101 |
| 101 | 102 |

<div class="mermaid">
graph TD
A[100]-->B(101)
A[100]-->C(102)
B[101]-->D(103)
C[102]-->B(101)
</div>

此时的更新流程：
- 删除101的输入、输出表记录；
- 重新生成101的输入、输出表记录；
- 删除101的上游依赖关系记录；
- 根据101的新的输入表重建其上游依赖关系；
- 删除所有父任务为101的依赖关系（保存原来依赖101的依赖关系）；
- 根据101的新的输出表重建其下游依赖关系
- 检查原来依赖101的依赖关系的任务，如果其没有父依赖，则将其父任务置为虚拟节点。

注：虽然上述流程能够完全更新上下游依赖，但是原则上不允许修改上游任务的输出。因为这样会导致下游依赖变得不可管理。

##### 依赖树展示
实际使用中，对依赖关系的查询和展示往往从一个指定的节点开始遍历其上游n层依赖和下游m层节点。通过依赖关系模型可以很轻易的实现上述目的。涉及两个主要操作,主要是获取给定节点的上游节点和下游节点：
- List<Depend> getDependsByJobId(jobId,level);
- List<Depend> getDependsByParentJobId(parentJobId,level);

#### 依赖环检测
如果让101读取102的输入表，则将形成101->103->102->101的依赖环。如下图所示，这种情况是要严厉禁止的。

<div class="mermaid">
graph TD
A[100]-->B(101)
A[100]-->C(102)
B[101]-->D(103)
C[102]-->B(101)
D[103]-->C(102)
</div>

关于有向无环图（DAG）的环检测算法可以通过图的深度遍历实现，有兴趣[参考](https://algs4.cs.princeton.edu/42digraph/)。
